use super::{Type, Ast, Block, UnaryOp, BinOp, LValue};

grammar;

ID = r"[a-zA-Z_]\w*";

NumI32: i32 = r"[0-9]+" => <>.parse().unwrap();
NumUSIZE: usize = r"[0-9]+" => <>.parse().unwrap();

Comma<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

Type: Type<'input> = {
	#[precedence(level="0")]
	ID => Type::Id(<>),
	#[precedence(level = "1")]
	<Type> "&" => Type::Pointer(Box::new(<>)),
	<ty:Type> "[" <len:NumUSIZE> "]" => Type::Array { ty: Box::new(ty), len },
	<Type> "[" "]" => Type::Slice(Box::new(<>)),
	#[precedence(level="2")] #[assoc(side="left")]
	<ret:Type> "(" <args:Comma<Type>> ")" => Type::FunctionPointer {
		ret: Box::new(ret),
		args
	}
}

pub Program: Vec<Ast<'input>> = Definition*;

Definition: Ast<'input> = {
	StructDef, UnionDef, EnumDef, FunctionDef
}

StructDef: Ast<'input> = 
	"struct" <name:ID> "{" <fields:(<Type> <ID> ";")*> "}" => Ast::StructDef { <> };

UnionDef: Ast<'input> = 
	"union" <name:ID> "{" <variants:(<Type> <ID> ";")*> "}" => Ast::UnionDef { <> };

EnumDef: Ast<'input> = 
	"enum" <name:ID> "{" <variants:Comma<(<ID> <("=" <NumI32>)?>)>> "}" => Ast::EnumDef { <> };

FunctionDef: Ast<'input> = 
	<ret:Type> <name:ID> "(" <args:Comma<(Type ID)>> ")" <body:Block> => Ast::FunctionDef { <> };

Block: Block<'input> = {
	"{" <statements:(Statement*)> <expr:(Expr?)> "}" => Block(statements, expr.map(Box::new))
}

Statement: Ast<'input> = {
	<ty:Type> <var:ID> <value:(("=" <Expr>)?)> ";" => Ast::Declare { ty, var, value: value.map(Box::new) },
	<var:LValue> "=" <value:Expr> ";" => Ast::Assign { var, value: Box::new(value) },
	<Expr> ";"
}

LValue: LValue<'input> = {
	ID => LValue::Id(<>),
	"*" <Expr> => LValue::Deref(Box::new(Ast::Id(<>))),
	<l:LValue> "[" <e:Expr> "]" => LValue::Index(Box::new(l), Box::new(e))
}

Expr: Ast<'input> = {
	#[precedence(level = "0")]
	Term,
	#[precedence(level = "1")] #[assoc(side="right")]
	"-" <Expr> => Ast::UnaryExpr(UnaryOp::Negate, Box::new(<>)),
	"&" <Expr> => Ast::UnaryExpr(UnaryOp::AddressOf, Box::new(<>)),
	"*" <Expr> => Ast::UnaryExpr(UnaryOp::Deref, Box::new(<>)),
	#[precedence(level = "2")] #[assoc(side="left")]
	<a:Expr> "%" <b:Expr> => Ast::BinExpr(Box::new(a), BinOp::Mod, Box::new(b)),
	#[precedence(level = "3")] #[assoc(side="left")]
	<a:Expr> "*" <b:Expr> => Ast::BinExpr(Box::new(a), BinOp::Mul, Box::new(b)),
	<a:Expr> "/" <b:Expr> => Ast::BinExpr(Box::new(a), BinOp::Div, Box::new(b)),
	#[precedence(level = "4")] #[assoc(side="left")]
	<a:Expr> "+" <b:Expr> => Ast::BinExpr(Box::new(a), BinOp::Add, Box::new(b)),
	<a:Expr> "-" <b:Expr> => Ast::BinExpr(Box::new(a), BinOp::Sub, Box::new(b)),
	#[precedence(level = "5")] #[assoc(side="left")]
	<a:Expr> ".." <b:Expr> => Ast::BinExpr(Box::new(a), BinOp::Range, Box::new(b)),
	#[precedence(level = "6")] #[assoc(side="left")]
	<a:Expr> "->" <b:Expr> => Ast::BinExpr(Box::new(a), BinOp::Pipeline, Box::new(b)),
	#[precedence(level = "7")] #[assoc(side="left")]
	<a:Expr> ">"  <b:Expr> => Ast::BinExpr(Box::new(a), BinOp::Gt, Box::new(b)),
	<a:Expr> ">=" <b:Expr> => Ast::BinExpr(Box::new(a), BinOp::Ge, Box::new(b)),
	<a:Expr> "<"  <b:Expr> => Ast::BinExpr(Box::new(a), BinOp::Lt, Box::new(b)),
	<a:Expr> "<=" <b:Expr> => Ast::BinExpr(Box::new(a), BinOp::Le, Box::new(b)),
	#[precedence(level = "8")] #[assoc(side="left")]
	<a:Expr> "==" <b:Expr> => Ast::BinExpr(Box::new(a), BinOp::Eq, Box::new(b)),
	<a:Expr> "!=" <b:Expr> => Ast::BinExpr(Box::new(a), BinOp::Ne, Box::new(b)),
}

Term: Ast<'input> = {
	ID => Ast::Id(<>),
	NumI32 => Ast::Num(<>),
	"(" <Expr> ")",
	"if" <cond:Expr> <block:Block> => Ast::IfExpr { cond: Box::new(cond), block },
	"for" <decl:(Type ID)> "in" <it:Expr> <body:Block> => Ast::ForExpr { decl, it: Box::new(it), body },
	//StructInit
}

// #[inline]
// StructInit: Ast<'input> = 
// 	<name:ID> "{" <fields:Comma<(<ID> "=" <Expr>)>> "}" => Ast::StructInit { <> };
